/* automatically generated by rust-bindgen 0.72.0 */

#[doc = "! Signed integer type used for aspif and solver literals."]
pub type clingo_literal_t = i32;
#[doc = "! Unsigned integer type used for aspif atoms."]
pub type clingo_atom_t = u32;
#[doc = "! Unsigned integer type used in various places."]
pub type clingo_id_t = u32;
#[doc = "! Signed integer type for weights in sum aggregates and minimize constraints."]
pub type clingo_weight_t = i32;
#[doc = "! A Literal with an associated weight."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_weighted_literal {
    pub literal: clingo_literal_t,
    pub weight: clingo_weight_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of clingo_weighted_literal"][::std::mem::size_of::<clingo_weighted_literal>() - 8usize];
    ["Alignment of clingo_weighted_literal"]
        [::std::mem::align_of::<clingo_weighted_literal>() - 4usize];
    ["Offset of field: clingo_weighted_literal::literal"]
        [::std::mem::offset_of!(clingo_weighted_literal, literal) - 0usize];
    ["Offset of field: clingo_weighted_literal::weight"]
        [::std::mem::offset_of!(clingo_weighted_literal, weight) - 4usize];
};
#[doc = "! A Literal with an associated weight."]
pub type clingo_weighted_literal_t = clingo_weighted_literal;
#[doc = "!< successful API calls"]
pub const clingo_error_e_clingo_error_success: clingo_error_e = 0;
#[doc = "!< errors only detectable at runtime like invalid input"]
pub const clingo_error_e_clingo_error_runtime: clingo_error_e = 1;
#[doc = "!< wrong usage of the clingo API"]
pub const clingo_error_e_clingo_error_logic: clingo_error_e = 2;
#[doc = "!< memory could not be allocated"]
pub const clingo_error_e_clingo_error_bad_alloc: clingo_error_e = 3;
#[doc = "!< errors unrelated to clingo"]
pub const clingo_error_e_clingo_error_unknown: clingo_error_e = 4;
#[doc = "! Enumeration of error codes.\n!\n! @note Errors can only be recovered from if explicitly mentioned; most\n! functions do not provide strong exception guarantees.  This means that in\n! case of errors associated objects cannot be used further.  If such an\n! object has a free function, this function can and should still be called."]
pub type clingo_error_e = ::std::os::raw::c_int;
#[doc = "! Corresponding type to ::clingo_error_e."]
pub type clingo_error_t = ::std::os::raw::c_int;
#[doc = "! Corresponding type to ::clingo_warning_e."]
pub type clingo_warning_t = ::std::os::raw::c_int;
#[doc = "! Callback to intercept warning messages.\n!\n! @param[in] code associated warning code\n! @param[in] message warning message\n! @param[in] data user data for callback\n!\n! @see clingo_control_new()\n! @see clingo_parse_term()\n! @see clingo_parse_program()"]
pub type clingo_logger_t = ::std::option::Option<
    unsafe extern "C" fn(
        code: clingo_warning_t,
        message: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    ),
>;
unsafe extern "C" {
    #[doc = "! Obtain the clingo version.\n!\n! @param[out] major major version number\n! @param[out] minor minor version number\n! @param[out] revision revision number"]
    pub fn clingo_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        revision: *mut ::std::os::raw::c_int,
    );
}
#[doc = "! Corresponding type to ::clingo_truth_value_e."]
pub type clingo_truth_value_t = ::std::os::raw::c_int;
#[doc = "! Represents a source code location marking its beginning and end.\n!\n! @note Not all locations refer to physical files.\n! By convention, such locations use a name put in angular brackets as filename.\n! The string members of a location object are internalized and valid for the duration of the process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_location {
    #[doc = "!< the file where the location begins"]
    pub begin_file: *const ::std::os::raw::c_char,
    #[doc = "!< the file where the location ends"]
    pub end_file: *const ::std::os::raw::c_char,
    #[doc = "!< the line where the location begins"]
    pub begin_line: usize,
    #[doc = "!< the line where the location ends"]
    pub end_line: usize,
    #[doc = "!< the column where the location begins"]
    pub begin_column: usize,
    #[doc = "!< the column where the location ends"]
    pub end_column: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of clingo_location"][::std::mem::size_of::<clingo_location>() - 48usize];
    ["Alignment of clingo_location"][::std::mem::align_of::<clingo_location>() - 8usize];
    ["Offset of field: clingo_location::begin_file"]
        [::std::mem::offset_of!(clingo_location, begin_file) - 0usize];
    ["Offset of field: clingo_location::end_file"]
        [::std::mem::offset_of!(clingo_location, end_file) - 8usize];
    ["Offset of field: clingo_location::begin_line"]
        [::std::mem::offset_of!(clingo_location, begin_line) - 16usize];
    ["Offset of field: clingo_location::end_line"]
        [::std::mem::offset_of!(clingo_location, end_line) - 24usize];
    ["Offset of field: clingo_location::begin_column"]
        [::std::mem::offset_of!(clingo_location, begin_column) - 32usize];
    ["Offset of field: clingo_location::end_column"]
        [::std::mem::offset_of!(clingo_location, end_column) - 40usize];
};
#[doc = "! Represents a source code location marking its beginning and end.\n!\n! @note Not all locations refer to physical files.\n! By convention, such locations use a name put in angular brackets as filename.\n! The string members of a location object are internalized and valid for the duration of the process."]
pub type clingo_location_t = clingo_location;
#[doc = "!< the <tt>\\#inf</tt> symbol"]
pub const clingo_symbol_type_e_clingo_symbol_type_infimum: clingo_symbol_type_e = 0;
#[doc = "!< a numeric symbol, e.g., `1`"]
pub const clingo_symbol_type_e_clingo_symbol_type_number: clingo_symbol_type_e = 1;
#[doc = "!< a string symbol, e.g., `\"a\"`"]
pub const clingo_symbol_type_e_clingo_symbol_type_string: clingo_symbol_type_e = 4;
#[doc = "!< a numeric symbol, e.g., `c`, `(1, \"a\")`, or `f(1,\"a\")`"]
pub const clingo_symbol_type_e_clingo_symbol_type_function: clingo_symbol_type_e = 5;
#[doc = "!< the <tt>\\#sup</tt> symbol"]
pub const clingo_symbol_type_e_clingo_symbol_type_supremum: clingo_symbol_type_e = 7;
#[doc = "! Enumeration of available symbol types."]
pub type clingo_symbol_type_e = ::std::os::raw::c_int;
#[doc = "! Corresponding type to ::clingo_symbol_type."]
pub type clingo_symbol_type_t = ::std::os::raw::c_int;
#[doc = "! Represents a symbol.\n!\n! This includes numbers, strings, functions (including constants when\n! arguments are empty and tuples when the name is empty), <tt>\\#inf</tt> and <tt>\\#sup</tt>."]
pub type clingo_symbol_t = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_symbolic_atoms {
    _unused: [u8; 0],
}
#[doc = "! Object to inspect symbolic atoms in a program---the relevant Herbrand base\n! gringo uses to instantiate programs.\n!\n! @see clingo_control_symbolic_atoms()"]
pub type clingo_symbolic_atoms_t = clingo_symbolic_atoms;
#[doc = "! Object to iterate over symbolic atoms.\n!\n! Such an iterator either points to a symbolic atom within a sequence of\n! symbolic atoms or to the end of the sequence.\n!\n! @note Iterators are valid as long as the underlying sequence is not modified.\n! Operations that can change this sequence are ::clingo_control_ground(),\n! ::clingo_control_cleanup(), and functions that modify the underlying\n! non-ground program."]
pub type clingo_symbolic_atom_iterator_t = u64;
#[doc = "! Callback function to inject symbols.\n!\n! @param symbols array of symbols\n! @param symbols_size size of the symbol array\n! @param data user data of the callback\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! @see ::clingo_ground_callback_t"]
pub type clingo_symbol_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        symbols: *const clingo_symbol_t,
        symbols_size: usize,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_theory_atoms {
    _unused: [u8; 0],
}
#[doc = "! Container that stores theory atoms, elements, and terms (see @ref clingo_control_theory_atoms())."]
pub type clingo_theory_atoms_t = clingo_theory_atoms;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_assignment {
    _unused: [u8; 0],
}
#[doc = "! Represents a (partial) assignment of a particular solver.\n!\n! An assignment assigns truth values to a set of literals.\n! A literal is assigned to either @link clingo_assignment_truth_value() true or false, or is unassigned@endlink.\n! Furthermore, each assigned literal is associated with a @link clingo_assignment_level() decision level@endlink.\n! There is exactly one @link clingo_assignment_decision() decision literal@endlink for each decision level greater\n! than zero. Assignments to all other literals on the same level are consequences implied by the current and possibly\n! previous decisions. Assignments on level zero are immediate consequences of the current program. Decision levels are\n! consecutive numbers starting with zero up to and including the @link clingo_assignment_decision_level() current\n! decision level@endlink."]
pub type clingo_assignment_t = clingo_assignment;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_propagate_init {
    _unused: [u8; 0],
}
#[doc = "! Object to initialize a user-defined propagator before each solving step.\n!\n! Each @link SymbolicAtoms symbolic@endlink or @link TheoryAtoms theory atom@endlink is uniquely associated with an\n! aspif atom in form of a positive integer (@ref ::clingo_literal_t). Aspif literals additionally are signed to\n! represent default negation. Furthermore, there are non-zero integer solver literals (also represented using @ref\n! ::clingo_literal_t). There is a surjective mapping from program atoms to solver literals.\n!\n! All methods called during propagation use solver literals whereas clingo_symbolic_atoms_literal() and\n! clingo_theory_atoms_atom_literal() return program literals. The function clingo_propagate_init_solver_literal() can\n! be used to map program literals or @link clingo_theory_atoms_element_condition_id() condition ids@endlink to solver\n! literals."]
pub type clingo_propagate_init_t = clingo_propagate_init;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_propagate_control {
    _unused: [u8; 0],
}
#[doc = "! This object can be used to add clauses and propagate literals while solving."]
pub type clingo_propagate_control_t = clingo_propagate_control;
#[doc = "! An instance of this struct has to be registered with a solver to implement a custom propagator.\n!\n! Not all callbacks have to be implemented and can be set to NULL if not needed.\n! @see Propagator"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_propagator {
    #[doc = "! This function is called once before each solving step.\n! It is used to map relevant program literals to solver literals, add watches for solver literals, and initialize\n! the data structures used during propagation.\n!\n! @note This is the last point to access symbolic and theory atoms.\n! Once the search has started, they are no longer accessible.\n!\n! @param[in] init initialization object\n! @param[in] data user data for the callback\n! @return whether the call was successful\n! @see ::clingo_propagator_init_callback_t"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            init: *mut clingo_propagate_init_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Can be used to propagate solver literals given a @link clingo_assignment_t partial assignment@endlink.\n!\n! Called during propagation with a non-empty array of @link clingo_propagate_init_add_watch() watched solver\n! literals@endlink that have been assigned to true since the last call to either propagate, undo, (or the start of\n! the search) - the change set. Only watched solver literals are contained in the change set. Each literal in the\n! change set is true w.r.t. the current @link clingo_assignment_t assignment@endlink.\n! @ref clingo_propagate_control_add_clause() can be used to add clauses.\n! If a clause is unit resulting, it can be propagated using @ref clingo_propagate_control_propagate().\n! If the result of either of the two methods is false, the propagate function must return immediately.\n!\n! The following snippet shows how to use the methods to add clauses and propagate consequences within the\n! callback. The important point is to return true (true to indicate there was no error) if the result of either of\n! the methods is false.\n! ~~~~~~~~~~~~~~~{.c}\n! bool result;\n! clingo_literal_t clause[] = { ... };\n!\n! // add a clause\n! if (!clingo_propagate_control_add_clause(control, clause, clingo_clause_type_learnt, &result) { return false; }\n! if (!result) { return true; }\n! // propagate its consequences\n! if (!clingo_propagate_control_propagate(control, &result) { return false; }\n! if (!result) { return true; }\n!\n! // add further clauses and propagate them\n! ...\n!\n! return true;\n! ~~~~~~~~~~~~~~~\n!\n! @note\n! This function can be called from different solving threads.\n! Each thread has its own assignment and id, which can be obtained using @ref\n! clingo_propagate_control_thread_id().\n!\n! @param[in] control control object for the target solver\n! @param[in] changes the change set\n! @param[in] size the size of the change set\n! @param[in] data user data for the callback\n! @return whether the call was successful\n! @see ::clingo_propagator_propagate_callback_t"]
    pub propagate: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_propagate_control_t,
            changes: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Called whenever a solver undoes assignments to watched solver literals.\n!\n! This callback is meant to update assignment dependent state in the propagator.\n!\n! @note No clauses must be propagated in this callback and no errors should be set.\n!\n! @param[in] control control object for the target solver\n! @param[in] changes the change set\n! @param[in] size the size of the change set\n! @param[in] data user data for the callback\n! @return whether the call was successful\n! @see ::clingo_propagator_undo_callback_t"]
    pub undo: ::std::option::Option<
        unsafe extern "C" fn(
            control: *const clingo_propagate_control_t,
            changes: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = "! This function is similar to @ref clingo_propagate_control_propagate() but is called without a change set on\n! propagation fixpoints.\n!\n! When exactly this function is called, can be configured using the @ref clingo_propagate_init_set_check_mode()\n! function.\n!\n! @note This function is called even if no watches have been added.\n!\n! @param[in] control control object for the target solver\n! @param[in] data user data for the callback\n! @return whether the call was successful\n! @see ::clingo_propagator_check_callback_t"]
    pub check: ::std::option::Option<
        unsafe extern "C" fn(
            control: *mut clingo_propagate_control_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! This function allows a propagator to implement domain-specific heuristics.\n!\n! It is called whenever propagation reaches a fixed point and\n! should return a free solver literal that is to be assigned true.\n! In case multiple propagators are registered,\n! this function can return 0 to let a propagator registered later make a decision.\n! If all propagators return 0, then the fallback literal is\n!\n! @param[in] thread_id the solver's thread id\n! @param[in] assignment the assignment of the solver\n! @param[in] fallback the literal chosen by the solver's heuristic\n! @param[out] decision the literal to make true\n! @return whether the call was successful"]
    pub decide: ::std::option::Option<
        unsafe extern "C" fn(
            thread_id: clingo_id_t,
            assignment: *const clingo_assignment_t,
            fallback: clingo_literal_t,
            data: *mut ::std::os::raw::c_void,
            decision: *mut clingo_literal_t,
        ) -> bool,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of clingo_propagator"][::std::mem::size_of::<clingo_propagator>() - 40usize];
    ["Alignment of clingo_propagator"][::std::mem::align_of::<clingo_propagator>() - 8usize];
    ["Offset of field: clingo_propagator::init"]
        [::std::mem::offset_of!(clingo_propagator, init) - 0usize];
    ["Offset of field: clingo_propagator::propagate"]
        [::std::mem::offset_of!(clingo_propagator, propagate) - 8usize];
    ["Offset of field: clingo_propagator::undo"]
        [::std::mem::offset_of!(clingo_propagator, undo) - 16usize];
    ["Offset of field: clingo_propagator::check"]
        [::std::mem::offset_of!(clingo_propagator, check) - 24usize];
    ["Offset of field: clingo_propagator::decide"]
        [::std::mem::offset_of!(clingo_propagator, decide) - 32usize];
};
#[doc = "! An instance of this struct has to be registered with a solver to implement a custom propagator.\n!\n! Not all callbacks have to be implemented and can be set to NULL if not needed.\n! @see Propagator"]
pub type clingo_propagator_t = clingo_propagator;
#[doc = "! Corresponding type to ::clingo_heuristic_type_e.\n! @ingroup ProgramInspection"]
pub type clingo_heuristic_type_t = ::std::os::raw::c_int;
#[doc = "! Corresponding type to ::clingo_external_type_e.\n! @ingroup ProgramInspection"]
pub type clingo_external_type_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_backend {
    _unused: [u8; 0],
}
#[doc = "! Handle to the backend to add directives in aspif format."]
pub type clingo_backend_t = clingo_backend;
#[doc = "! Bitset for values of type ::clingo_configuration_type_e."]
pub type clingo_configuration_type_bitset_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_configuration {
    _unused: [u8; 0],
}
#[doc = "! Handle for to the solver configuration."]
pub type clingo_configuration_t = clingo_configuration;
unsafe extern "C" {
    #[doc = "! Get the root key of the configuration.\n!\n! @param[in] configuration the target configuration\n! @param[out] key the root key\n! @return whether the call was successful"]
    pub fn clingo_configuration_root(
        configuration: *const clingo_configuration_t,
        key: *mut clingo_id_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the type of a key.\n!\n! @note The type is bitset, an entry can have multiple (but at least one) type.\n!\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] type the resulting type\n! @return whether the call was successful"]
    pub fn clingo_configuration_type(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        type_: *mut clingo_configuration_type_bitset_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the description of an entry.\n!\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] description the description\n! @return whether the call was successful"]
    pub fn clingo_configuration_description(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        description: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the size of an array entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] size the resulting size\n! @return whether the call was successful"]
    pub fn clingo_configuration_array_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the subkey at the given offset of an array entry.\n!\n! @note Some array entries, like fore example the solver configuration, can be accessed past there actual size to add\n! subentries.\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_array.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] offset the offset in the array\n! @param[out] subkey the resulting subkey\n! @return whether the call was successful"]
    pub fn clingo_configuration_array_at(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        offset: usize,
        subkey: *mut clingo_id_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the number of subkeys of a map entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] size the resulting number\n! @return whether the call was successful"]
    pub fn clingo_configuration_map_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Query whether the map has a key.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.\n! @note Multiple levels can be looked up by concatenating keys with a period.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] name the name to look up the subkey\n! @param[out] result whether the key is in the map\n! @return whether the call was successful"]
    pub fn clingo_configuration_map_has_subkey(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        name: *const ::std::os::raw::c_char,
        result: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the name associated with the offset-th subkey.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] offset the offset of the name\n! @param[out] name the resulting name\n! @return whether the call was successful"]
    pub fn clingo_configuration_map_subkey_name(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        offset: usize,
        name: *mut *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Lookup a subkey under the given name.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_map.\n! @note Multiple levels can be looked up by concatenating keys with a period.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] name the name to look up the subkey\n! @param[out] subkey the resulting subkey\n! @return whether the call was successful"]
    pub fn clingo_configuration_map_at(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        name: *const ::std::os::raw::c_char,
        subkey: *mut clingo_id_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Check whether an entry has a value.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] assigned whether the entry has a value\n! @return whether the call was successful"]
    pub fn clingo_configuration_value_is_assigned(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        assigned: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the size of the string value of the given entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] size the resulting size\n! @return whether the call was successful"]
    pub fn clingo_configuration_value_get_size(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        size: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the string value of the given entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.\n! @pre The given size must be larger or equal to size of the value.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[out] value the resulting string value\n! @param[in] size the size of the given char array\n! @return whether the call was successful"]
    pub fn clingo_configuration_value_get(
        configuration: *const clingo_configuration_t,
        key: clingo_id_t,
        value: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Set the value of an entry.\n!\n! @pre The @link clingo_configuration_type() type@endlink of the entry must be @ref ::clingo_configuration_type_value.\n! @param[in] configuration the target configuration\n! @param[in] key the key\n! @param[in] value the value to set\n! @return whether the call was successful"]
    pub fn clingo_configuration_value_set(
        configuration: *mut clingo_configuration_t,
        key: clingo_id_t,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_statistic {
    _unused: [u8; 0],
}
#[doc = "! Handle for the solver statistics."]
pub type clingo_statistics_t = clingo_statistic;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_solve_control {
    _unused: [u8; 0],
}
#[doc = "! Object to add clauses during search."]
pub type clingo_solve_control_t = clingo_solve_control;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_model {
    _unused: [u8; 0],
}
#[doc = "! Object representing a model."]
pub type clingo_model_t = clingo_model;
#[doc = "!< The model represents a stable model."]
pub const clingo_model_type_e_clingo_model_type_stable_model: clingo_model_type_e = 0;
#[doc = "!< The model represents a set of brave consequences."]
pub const clingo_model_type_e_clingo_model_type_brave_consequences: clingo_model_type_e = 1;
#[doc = "!< The model represents a set of cautious consequences."]
pub const clingo_model_type_e_clingo_model_type_cautious_consequences: clingo_model_type_e = 2;
#[doc = "! Enumeration for the different model types."]
pub type clingo_model_type_e = ::std::os::raw::c_int;
#[doc = "! Corresponding type to ::clingo_model_type_e."]
pub type clingo_model_type_t = ::std::os::raw::c_int;
#[doc = "! Corresponding type to ::clingo_show_type_e."]
pub type clingo_show_type_bitset_t = ::std::os::raw::c_uint;
pub type clingo_consequence_t = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = "! Get the type of the model.\n!\n! @param[in] model the target\n! @param[out] type the type of the model\n! @return whether the call was successful"]
    pub fn clingo_model_type(model: *const clingo_model_t, type_: *mut clingo_model_type_t)
    -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the running number of the model.\n!\n! @param[in] model the target\n! @param[out] number the number of the model\n! @return whether the call was successful"]
    pub fn clingo_model_number(model: *const clingo_model_t, number: *mut u64) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the number of symbols of the selected types in the model.\n!\n! @param[in] model the target\n! @param[in] show which symbols to select\n! @param[out] size the number symbols\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_model_symbols_size(
        model: *const clingo_model_t,
        show: clingo_show_type_bitset_t,
        size: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the symbols of the selected types in the model.\n!\n! @note CSP assignments are represented using functions with name \"$\"\n! where the first argument is the name of the CSP variable and the second one its\n! value.\n!\n! @param[in] model the target\n! @param[in] show which symbols to select\n! @param[out] symbols the resulting symbols\n! @param[in] size the number of selected symbols\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if the size is too small\n!\n! @see clingo_model_symbols_size()"]
    pub fn clingo_model_symbols(
        model: *const clingo_model_t,
        show: clingo_show_type_bitset_t,
        symbols: *mut clingo_symbol_t,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Constant time lookup to test whether an atom is in a model.\n!\n! @param[in] model the target\n! @param[in] atom the atom to lookup\n! @param[out] contained whether the atom is contained\n! @return whether the call was successful"]
    pub fn clingo_model_contains(
        model: *const clingo_model_t,
        atom: clingo_symbol_t,
        contained: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Check if a program literal is true in a model.\n!\n! @param[in] model the target\n! @param[in] literal the literal to lookup\n! @param[out] result whether the literal is true\n! @return whether the call was successful"]
    pub fn clingo_model_is_true(
        model: *const clingo_model_t,
        literal: clingo_literal_t,
        result: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Check if the given literal is a consequence.\n!\n! While enumerating cautious or brave consequences, there is partial\n! information about which literals are consequences. The current state of a\n! literal can be requested using this function. If this function is used\n! during normal model enumeration, the function just returns whether a\n! literal is true of false in the current model.\n!\n! @param[in] model the target\n! @param[in] literal the literal to lookup\n! @param[out] result whether the literal is a consequence\n! @return whether the call was successful"]
    pub fn clingo_model_is_consequence(
        model: *const clingo_model_t,
        literal: clingo_literal_t,
        result: *mut clingo_consequence_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the number of cost values of a model.\n!\n! @param[in] model the target\n! @param[out] size the number of costs\n! @return whether the call was successful"]
    pub fn clingo_model_cost_size(model: *const clingo_model_t, size: *mut usize) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the cost vector of a model.\n!\n! @param[in] model the target\n! @param[out] costs the resulting costs\n! @param[in] size the number of costs\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if the size is too small\n!\n! @see clingo_model_cost_size()\n! @see clingo_model_optimality_proven()"]
    pub fn clingo_model_cost(model: *const clingo_model_t, costs: *mut i64, size: usize) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the priorities of the costs.\n!\n! The size of the array can be obtained with clingo_model_cost_size().\n!\n! @param[in] model the target\n! @param[out] priorities the resulting priorities\n! @param[in] size the number of priorities\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if the size is too small\n!\n! @see clingo_model_cost_size()"]
    pub fn clingo_model_priority(
        model: *const clingo_model_t,
        priorities: *mut clingo_weight_t,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Whether the optimality of a model has been proven.\n!\n! @param[in] model the target\n! @param[out] proven whether the optimality has been proven\n! @return whether the call was successful\n!\n! @see clingo_model_cost()"]
    pub fn clingo_model_optimality_proven(model: *const clingo_model_t, proven: *mut bool) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the id of the solver thread that found the model.\n!\n! @param[in] model the target\n! @param[out] id the resulting thread id\n! @return whether the call was successful"]
    pub fn clingo_model_thread_id(model: *const clingo_model_t, id: *mut clingo_id_t) -> bool;
}
unsafe extern "C" {
    #[doc = "! Add symbols to the model.\n!\n! These symbols will appear in clingo's output, which means that this\n! function is only meaningful if there is an underlying clingo application.\n! Only models passed to the ::clingo_solve_event_callback_t are extendable.\n!\n! @param[in] model the target\n! @param[in] symbols the symbols to add\n! @param[in] size the number of symbols to add\n! @return whether the call was successful"]
    pub fn clingo_model_extend(
        model: *mut clingo_model_t,
        symbols: *const clingo_symbol_t,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get the associated solve control object of a model.\n!\n! This object allows for adding clauses during model enumeration.\n! @param[in] model the target\n! @param[out] control the resulting solve control object\n! @return whether the call was successful"]
    pub fn clingo_model_context(
        model: *const clingo_model_t,
        control: *mut *mut clingo_solve_control_t,
    ) -> bool;
}
pub type clingo_solve_result_bitset_t = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_solve_mode_e."]
pub type clingo_solve_mode_bitset_t = ::std::os::raw::c_uint;
#[doc = "! Corresponding type to ::clingo_solve_event_type_e."]
pub type clingo_solve_event_type_t = ::std::os::raw::c_uint;
#[doc = "! Callback function called during search to notify when the search is finished or a model is ready.\n!\n! If a (non-recoverable) clingo API function fails in this callback, it must return false.\n! In case of errors not related to clingo, set error code ::clingo_error_unknown and return false to stop solving with\n! an error.\n!\n! The event is either a pointer to a model, a pointer to an int64_t* and a size_t, a pointer to two statistics objects\n! (per step and accumulated statistics), or a solve result.\n! @attention If the search is finished, the model is NULL.\n!\n! @param[in] event the current event.\n! @param[in] data user data of the callback\n! @param[out] goon can be set to false to stop solving\n! @return whether the call was successful\n!\n! @see clingo_control_solve()"]
pub type clingo_solve_event_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        type_: clingo_solve_event_type_t,
        event: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        goon: *mut bool,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_solve_handle {
    _unused: [u8; 0],
}
#[doc = "! Search handle to a solve call.\n!\n! @see clingo_control_solve()"]
pub type clingo_solve_handle_t = clingo_solve_handle;
unsafe extern "C" {
    #[doc = "! Get the next solve result.\n!\n! Blocks until the result is ready.\n! When yielding partial solve results can be obtained, i.e.,\n! when a model is ready, the result will be satisfiable but neither the search exhausted nor the optimality proven.\n!\n! @param[in] handle the target\n! @param[out] result the solve result\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_get(
        handle: *mut clingo_solve_handle_t,
        result: *mut clingo_solve_result_bitset_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Wait for the specified amount of time to check if the next result is ready.\n!\n! If the time is set to zero, this function can be used to poll if the search is still active.\n! If the time is negative, the function blocks until the search is finished.\n!\n! @param[in] handle the target\n! @param[in] timeout the maximum time to wait\n! @param[out] result whether the search has finished"]
    pub fn clingo_solve_handle_wait(
        handle: *mut clingo_solve_handle_t,
        timeout: f64,
        result: *mut bool,
    );
}
unsafe extern "C" {
    #[doc = "! Get the next model (or zero if there are no more models).\n!\n! @param[in] handle the target\n! @param[out] model the model (it is NULL if there are no more models)\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_model(
        handle: *mut clingo_solve_handle_t,
        model: *mut *const clingo_model_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! When a problem is unsatisfiable, get a subset of the assumptions that made the problem unsatisfiable.\n!\n! If the program is not unsatisfiable, core is set to NULL and size to zero.\n!\n! @param[in] handle the target\n! @param[out] core pointer where to store the core\n! @param[out] size size of the given array\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_solve_handle_core(
        handle: *mut clingo_solve_handle_t,
        core: *mut *const clingo_literal_t,
        size: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! When a problem is satisfiable and the search is finished, get the last computed model.\n!\n! If the program is unsatisfiable or the search is not finished, model is set to NULL.\n!\n! @param[in] handle the target\n! @param[out] model the last computed model (or NULL if the program is unsatisfiable or the search is still ongoing)\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_last(
        handle: *mut clingo_solve_handle_t,
        model: *mut *const clingo_model_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Discards the last model and starts the search for the next one.\n!\n! If the search has been started asynchronously, this function continues the search in the background.\n!\n! @note This function does not block.\n!\n! @param[in] handle the target\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_resume(handle: *mut clingo_solve_handle_t) -> bool;
}
unsafe extern "C" {
    #[doc = "! Stop the running search and block until done.\n!\n! @param[in] handle the target\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_cancel(handle: *mut clingo_solve_handle_t) -> bool;
}
unsafe extern "C" {
    #[doc = "! Stops the running search and releases the handle.\n!\n! Blocks until the search is stopped (as if an implicit cancel was called before the handle is released).\n!\n! @param[in] handle the target\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving fails"]
    pub fn clingo_solve_handle_close(handle: *mut clingo_solve_handle_t) -> bool;
}
#[doc = "! An instance of this struct has to be registered with a solver to observe ground directives as they are passed to the\n! solver.\n!\n! @note This interface is closely modeled after the aspif format.\n! For more information please refer to the specification of the aspif format.\n!\n! Not all callbacks have to be implemented and can be set to NULL if not needed.\n! If one of the callbacks in the struct fails, grounding is stopped.\n! If a non-recoverable clingo API call fails, a callback must return false.\n! Otherwise ::clingo_error_unknown should be set and false returned.\n!\n! @see clingo_control_register_observer()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_ground_program_observer {
    #[doc = "! Called once in the beginning.\n!\n! If the incremental flag is true, there can be multiple calls to @ref clingo_control_solve().\n!\n! @param[in] incremental whether the program is incremental\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub init_program: ::std::option::Option<
        unsafe extern "C" fn(incremental: bool, data: *mut ::std::os::raw::c_void) -> bool,
    >,
    #[doc = "! Marks the beginning of a block of directives passed to the solver.\n!\n! @see @ref end_step\n!\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub begin_step:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    #[doc = "! Marks the end of a block of directives passed to the solver.\n!\n! This function is called before solving starts.\n!\n! @see @ref begin_step\n!\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub end_step:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>,
    #[doc = "! Observe rules passed to the solver.\n!\n! @param[in] choice determines if the head is a choice or a disjunction\n! @param[in] head the head atoms\n! @param[in] head_size the number of atoms in the head\n! @param[in] body the body literals\n! @param[in] body_size the number of literals in the body\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub rule: ::std::option::Option<
        unsafe extern "C" fn(
            choice: bool,
            head: *const clingo_atom_t,
            head_size: usize,
            body: *const clingo_literal_t,
            body_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe weight rules passed to the solver.\n!\n! @param[in] choice determines if the head is a choice or a disjunction\n! @param[in] head the head atoms\n! @param[in] head_size the number of atoms in the head\n! @param[in] lower_bound the lower bound of the weight rule\n! @param[in] body the weighted body literals\n! @param[in] body_size the number of weighted literals in the body\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub weight_rule: ::std::option::Option<
        unsafe extern "C" fn(
            choice: bool,
            head: *const clingo_atom_t,
            head_size: usize,
            lower_bound: clingo_weight_t,
            body: *const clingo_weighted_literal_t,
            body_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe minimize constraints (or weak constraints) passed to the solver.\n!\n! @param[in] priority the priority of the constraint\n! @param[in] literals the weighted literals whose sum to minimize\n! @param[in] size the number of weighted literals\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub minimize: ::std::option::Option<
        unsafe extern "C" fn(
            priority: clingo_weight_t,
            literals: *const clingo_weighted_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe projection directives passed to the solver.\n!\n! @param[in] atoms the atoms to project on\n! @param[in] size the number of atoms\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub project: ::std::option::Option<
        unsafe extern "C" fn(
            atoms: *const clingo_atom_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown atoms passed to the solver.\n! \\note Facts do not have an associated aspif atom.\n! The value of the atom is set to zero.\n!\n! @param[in] symbol the symbolic representation of the atom\n! @param[in] atom the aspif atom (0 for facts)\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub output_atom: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            atom: clingo_atom_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe shown terms passed to the solver.\n!\n! @param[in] symbol the symbolic representation of the term\n! @param[in] condition the literals of the condition\n! @param[in] size the size of the condition\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub output_term: ::std::option::Option<
        unsafe extern "C" fn(
            symbol: clingo_symbol_t,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe external statements passed to the solver.\n!\n! @param[in] atom the external atom\n! @param[in] type the type of the external statement\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub external: ::std::option::Option<
        unsafe extern "C" fn(
            atom: clingo_atom_t,
            type_: clingo_external_type_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe assumption directives passed to the solver.\n!\n! @param[in] literals the literals to assume (positive literals are true and negative literals false for the next\n! solve call)\n! @param[in] size the number of atoms\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub assume: ::std::option::Option<
        unsafe extern "C" fn(
            literals: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe heuristic directives passed to the solver.\n!\n! @param[in] atom the target atom\n! @param[in] type the type of the heuristic modification\n! @param[in] bias the heuristic bias\n! @param[in] priority the heuristic priority\n! @param[in] condition the condition under which to apply the heuristic modification\n! @param[in] size the number of atoms in the condition\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub heuristic: ::std::option::Option<
        unsafe extern "C" fn(
            atom: clingo_atom_t,
            type_: clingo_heuristic_type_t,
            bias: ::std::os::raw::c_int,
            priority: ::std::os::raw::c_uint,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe edge directives passed to the solver.\n!\n! @param[in] node_u the start vertex of the edge\n! @param[in] node_v the end vertex of the edge\n! @param[in] condition the condition under which the edge is part of the graph\n! @param[in] size the number of atoms in the condition\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub acyc_edge: ::std::option::Option<
        unsafe extern "C" fn(
            node_u: ::std::os::raw::c_int,
            node_v: ::std::os::raw::c_int,
            condition: *const clingo_literal_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe numeric theory terms.\n!\n! @param[in] term_id the id of the term\n! @param[in] number the value of the term\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_term_number: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            number: ::std::os::raw::c_int,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe string theory terms.\n!\n! @param[in] term_id the id of the term\n! @param[in] name the value of the term\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_term_string: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            name: *const ::std::os::raw::c_char,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe compound theory terms.\n!\n! The name_id_or_type gives the type of the compound term:\n! - if it is -1, then it is a tuple\n! - if it is -2, then it is a set\n! - if it is -3, then it is a list\n! - otherwise, it is a function and name_id_or_type refers to the id of the name (in form of a string term)\n!\n! @param[in] term_id the id of the term\n! @param[in] name_id_or_type the name or type of the term\n! @param[in] arguments the arguments of the term\n! @param[in] size the number of arguments\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_term_compound: ::std::option::Option<
        unsafe extern "C" fn(
            term_id: clingo_id_t,
            name_id_or_type: ::std::os::raw::c_int,
            arguments: *const clingo_id_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory elements.\n!\n! @param element_id the id of the element\n! @param terms the term tuple of the element\n! @param terms_size the number of terms in the tuple\n! @param condition the condition of the elemnt\n! @param condition_size the number of literals in the condition\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_element: ::std::option::Option<
        unsafe extern "C" fn(
            element_id: clingo_id_t,
            terms: *const clingo_id_t,
            terms_size: usize,
            condition: *const clingo_literal_t,
            condition_size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory atoms without guard.\n!\n! @param[in] atom_id_or_zero the id of the atom or zero for directives\n! @param[in] term_id the term associated with the atom\n! @param[in] elements the elements of the atom\n! @param[in] size the number of elements\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_atom: ::std::option::Option<
        unsafe extern "C" fn(
            atom_id_or_zero: clingo_id_t,
            term_id: clingo_id_t,
            elements: *const clingo_id_t,
            size: usize,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
    #[doc = "! Observe theory atoms with guard.\n!\n! @param[in] atom_id_or_zero the id of the atom or zero for directives\n! @param[in] term_id the term associated with the atom\n! @param[in] elements the elements of the atom\n! @param[in] size the number of elements\n! @param[in] operator_id the id of the operator (a string term)\n! @param[in] right_hand_side_id the id of the term on the right hand side of the atom\n! @param[in] data user data for the callback\n! @return whether the call was successful"]
    pub theory_atom_with_guard: ::std::option::Option<
        unsafe extern "C" fn(
            atom_id_or_zero: clingo_id_t,
            term_id: clingo_id_t,
            elements: *const clingo_id_t,
            size: usize,
            operator_id: clingo_id_t,
            right_hand_side_id: clingo_id_t,
            data: *mut ::std::os::raw::c_void,
        ) -> bool,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of clingo_ground_program_observer"]
        [::std::mem::size_of::<clingo_ground_program_observer>() - 152usize];
    ["Alignment of clingo_ground_program_observer"]
        [::std::mem::align_of::<clingo_ground_program_observer>() - 8usize];
    ["Offset of field: clingo_ground_program_observer::init_program"]
        [::std::mem::offset_of!(clingo_ground_program_observer, init_program) - 0usize];
    ["Offset of field: clingo_ground_program_observer::begin_step"]
        [::std::mem::offset_of!(clingo_ground_program_observer, begin_step) - 8usize];
    ["Offset of field: clingo_ground_program_observer::end_step"]
        [::std::mem::offset_of!(clingo_ground_program_observer, end_step) - 16usize];
    ["Offset of field: clingo_ground_program_observer::rule"]
        [::std::mem::offset_of!(clingo_ground_program_observer, rule) - 24usize];
    ["Offset of field: clingo_ground_program_observer::weight_rule"]
        [::std::mem::offset_of!(clingo_ground_program_observer, weight_rule) - 32usize];
    ["Offset of field: clingo_ground_program_observer::minimize"]
        [::std::mem::offset_of!(clingo_ground_program_observer, minimize) - 40usize];
    ["Offset of field: clingo_ground_program_observer::project"]
        [::std::mem::offset_of!(clingo_ground_program_observer, project) - 48usize];
    ["Offset of field: clingo_ground_program_observer::output_atom"]
        [::std::mem::offset_of!(clingo_ground_program_observer, output_atom) - 56usize];
    ["Offset of field: clingo_ground_program_observer::output_term"]
        [::std::mem::offset_of!(clingo_ground_program_observer, output_term) - 64usize];
    ["Offset of field: clingo_ground_program_observer::external"]
        [::std::mem::offset_of!(clingo_ground_program_observer, external) - 72usize];
    ["Offset of field: clingo_ground_program_observer::assume"]
        [::std::mem::offset_of!(clingo_ground_program_observer, assume) - 80usize];
    ["Offset of field: clingo_ground_program_observer::heuristic"]
        [::std::mem::offset_of!(clingo_ground_program_observer, heuristic) - 88usize];
    ["Offset of field: clingo_ground_program_observer::acyc_edge"]
        [::std::mem::offset_of!(clingo_ground_program_observer, acyc_edge) - 96usize];
    ["Offset of field: clingo_ground_program_observer::theory_term_number"]
        [::std::mem::offset_of!(clingo_ground_program_observer, theory_term_number) - 104usize];
    ["Offset of field: clingo_ground_program_observer::theory_term_string"]
        [::std::mem::offset_of!(clingo_ground_program_observer, theory_term_string) - 112usize];
    ["Offset of field: clingo_ground_program_observer::theory_term_compound"]
        [::std::mem::offset_of!(clingo_ground_program_observer, theory_term_compound) - 120usize];
    ["Offset of field: clingo_ground_program_observer::theory_element"]
        [::std::mem::offset_of!(clingo_ground_program_observer, theory_element) - 128usize];
    ["Offset of field: clingo_ground_program_observer::theory_atom"]
        [::std::mem::offset_of!(clingo_ground_program_observer, theory_atom) - 136usize];
    ["Offset of field: clingo_ground_program_observer::theory_atom_with_guard"]
        [::std::mem::offset_of!(clingo_ground_program_observer, theory_atom_with_guard) - 144usize];
};
#[doc = "! An instance of this struct has to be registered with a solver to observe ground directives as they are passed to the\n! solver.\n!\n! @note This interface is closely modeled after the aspif format.\n! For more information please refer to the specification of the aspif format.\n!\n! Not all callbacks have to be implemented and can be set to NULL if not needed.\n! If one of the callbacks in the struct fails, grounding is stopped.\n! If a non-recoverable clingo API call fails, a callback must return false.\n! Otherwise ::clingo_error_unknown should be set and false returned.\n!\n! @see clingo_control_register_observer()"]
pub type clingo_ground_program_observer_t = clingo_ground_program_observer;
#[doc = "! Struct used to specify the program parts that have to be grounded.\n!\n! Programs may be structured into parts, which can be grounded independently with ::clingo_control_ground.\n! Program parts are mainly interesting for incremental grounding and multi-shot solving.\n! For single-shot solving, program parts are not needed.\n!\n! @note Parts of a logic program without an explicit <tt>\\#program</tt>\n! specification are by default put into a program called `base` without\n! arguments.\n!\n! @see clingo_control_ground()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clingo_part {
    #[doc = "!< name of the program part"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "!< array of parameters"]
    pub params: *const clingo_symbol_t,
    #[doc = "!< number of parameters"]
    pub size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of clingo_part"][::std::mem::size_of::<clingo_part>() - 24usize];
    ["Alignment of clingo_part"][::std::mem::align_of::<clingo_part>() - 8usize];
    ["Offset of field: clingo_part::name"][::std::mem::offset_of!(clingo_part, name) - 0usize];
    ["Offset of field: clingo_part::params"][::std::mem::offset_of!(clingo_part, params) - 8usize];
    ["Offset of field: clingo_part::size"][::std::mem::offset_of!(clingo_part, size) - 16usize];
};
#[doc = "! Struct used to specify the program parts that have to be grounded.\n!\n! Programs may be structured into parts, which can be grounded independently with ::clingo_control_ground.\n! Program parts are mainly interesting for incremental grounding and multi-shot solving.\n! For single-shot solving, program parts are not needed.\n!\n! @note Parts of a logic program without an explicit <tt>\\#program</tt>\n! specification are by default put into a program called `base` without\n! arguments.\n!\n! @see clingo_control_ground()"]
pub type clingo_part_t = clingo_part;
#[doc = "! Callback function to implement external functions.\n!\n! If an external function of form <tt>\\@name(parameters)</tt> occurs in a logic program,\n! then this function is called with its location, name, parameters, and a callback to inject symbols as arguments.\n! The callback can be called multiple times; all symbols passed are injected.\n!\n! If a (non-recoverable) clingo API function fails in this callback, for example, the symbol callback, the callback\n! must return false. In case of errors not related to clingo, this function can set error ::clingo_error_unknown and\n! return false to stop grounding with an error.\n!\n! @param[in] location location from which the external function was called\n! @param[in] name name of the called external function\n! @param[in] arguments arguments of the called external function\n! @param[in] arguments_size number of arguments\n! @param[in] data user data of the callback\n! @param[in] symbol_callback function to inject symbols\n! @param[in] symbol_callback_data user data for the symbol callback\n!            (must be passed untouched)\n! @return whether the call was successful\n! @see clingo_control_ground()\n!\n! The following example implements the external function <tt>\\@f()</tt> returning 42.\n! ~~~~~~~~~~~~~~~{.c}\n! bool\n! ground_callback(clingo_location_t const *location,\n!                 char const *name,\n!                 clingo_symbol_t const *arguments,\n!                 size_t arguments_size,\n!                 void *data,\n!                 clingo_symbol_callback_t symbol_callback,\n!                 void *symbol_callback_data) {\n!   if (strcmp(name, \"f\") == 0 && arguments_size == 0) {\n!     clingo_symbol_t sym;\n!     clingo_symbol_create_number(42, &sym);\n!     return symbol_callback(&sym, 1, symbol_callback_data);\n!   }\n!   clingo_set_error(clingo_error_runtime, \"function not found\");\n!   return false;\n! }\n! ~~~~~~~~~~~~~~~"]
pub type clingo_ground_callback_t = ::std::option::Option<
    unsafe extern "C" fn(
        location: *const clingo_location_t,
        name: *const ::std::os::raw::c_char,
        arguments: *const clingo_symbol_t,
        arguments_size: usize,
        data: *mut ::std::os::raw::c_void,
        symbol_callback: clingo_symbol_callback_t,
        symbol_callback_data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = "! Corresponding type to clingo_backend_type_e."]
pub type clingo_backend_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug)]
pub struct clingo_control {
    _unused: [u8; 0],
}
#[doc = "! Control object holding grounding and solving state."]
pub type clingo_control_t = clingo_control;
unsafe extern "C" {
    #[doc = "! Create a new control object.\n!\n! A control object has to be freed using clingo_control_free().\n!\n! @note Only gringo options (without <code>\\-\\-output</code>) and clasp's options are supported as arguments,\n! except basic options such as <code>\\-\\-help</code>.\n! Furthermore, a control object is blocked while a search call is active;\n! you must not call any member function during search.\n!\n! If the logger is NULL, messages are printed to stderr.\n!\n! @param[in] arguments C string array of command line arguments\n! @param[in] arguments_size size of the arguments array\n! @param[in] logger callback functions for warnings and info messages\n! @param[in] logger_data user data for the logger callback\n! @param[in] message_limit maximum number of times the logger callback is called\n! @param[out] control resulting control object\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if argument parsing fails"]
    pub fn clingo_control_new(
        arguments: *const *const ::std::os::raw::c_char,
        arguments_size: usize,
        logger: clingo_logger_t,
        logger_data: *mut ::std::os::raw::c_void,
        message_limit: ::std::os::raw::c_uint,
        control: *mut *mut clingo_control_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Free a control object created with clingo_control_new().\n! @param[in] control the target"]
    pub fn clingo_control_free(control: *mut clingo_control_t);
}
unsafe extern "C" {
    #[doc = "! Extend the logic program with a program in a file.\n!\n! @param[in] control the target\n! @param[in] file path to the file\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if parsing or checking fails"]
    pub fn clingo_control_load(
        control: *mut clingo_control_t,
        file: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Load files in aspif format.\n!\n! This function should be called on an empty control object.\n!\n! If more than one file is given, they are merged into one file. Only the first one should have a preamble.\n!\n! @param[in] control the target\n! @param[in] files the array of files to load\n! @param[in] size the size of the array\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if parsing or checking fails"]
    pub fn clingo_control_load_aspif(
        control: *mut clingo_control_t,
        files: *mut *const ::std::os::raw::c_char,
        size: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Extend the logic program with the given non-ground logic program in string form.\n!\n! This function puts the given program into a block of form: <tt>\\#program name(parameters).</tt>\n!\n! After extending the logic program, the corresponding program parts are typically grounded with\n! ::clingo_control_ground.\n!\n! @param[in] control the target\n! @param[in] name name of the program block\n! @param[in] parameters string array of parameters of the program block\n! @param[in] parameters_size number of parameters\n! @param[in] program string representation of the program\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if parsing fails"]
    pub fn clingo_control_add(
        control: *mut clingo_control_t,
        name: *const ::std::os::raw::c_char,
        parameters: *const *const ::std::os::raw::c_char,
        parameters_size: usize,
        program: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Ground the selected @link ::clingo_part parts @endlink of the current (non-ground) logic program.\n!\n! After grounding, logic programs can be solved with ::clingo_control_solve().\n!\n! @note Parts of a logic program without an explicit <tt>\\#program</tt>\n! specification are by default put into a program called `base` without\n! arguments.\n!\n! @param[in] control the target\n! @param[in] parts array of parts to ground\n! @param[in] parts_size size of the parts array\n! @param[in] ground_callback callback to implement external functions\n! @param[in] ground_callback_data user data for ground_callback\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - error code of ground callback\n!\n! @see clingo_part"]
    pub fn clingo_control_ground(
        control: *mut clingo_control_t,
        parts: *const clingo_part_t,
        parts_size: usize,
        ground_callback: clingo_ground_callback_t,
        ground_callback_data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Solve the currently @link ::clingo_control_ground grounded @endlink logic program enumerating its models.\n!\n! See the @ref SolveHandle module for more information.\n!\n! @param[in] control the target\n! @param[in] mode configures the search mode\n! @param[in] assumptions array of assumptions to solve under\n! @param[in] assumptions_size number of assumptions\n! @param[in] notify the event handler to register\n! @param[in] data the user data for the event handler\n! @param[out] handle handle to the current search to enumerate models\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime if solving could not be started"]
    pub fn clingo_control_solve(
        control: *mut clingo_control_t,
        mode: clingo_solve_mode_bitset_t,
        assumptions: *const clingo_literal_t,
        assumptions_size: usize,
        notify: clingo_solve_event_callback_t,
        data: *mut ::std::os::raw::c_void,
        handle: *mut *mut clingo_solve_handle_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! @param[in] control the target\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n!\n! @see clingo_control_get_enable_cleanup()\n! @see clingo_control_set_enable_cleanup()"]
    pub fn clingo_control_cleanup(control: *mut clingo_control_t) -> bool;
}
unsafe extern "C" {
    #[doc = "! Assign a truth value to an external atom.\n!\n! If a negative literal is passed, the corresponding atom is assigned the\n! inverted truth value.\n!\n! If the atom does not exist or is not external, this is a noop.\n!\n! @param[in] control the target\n! @param[in] literal literal to assign\n! @param[in] value the truth value\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_assign_external(
        control: *mut clingo_control_t,
        literal: clingo_literal_t,
        value: clingo_truth_value_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Release an external atom.\n!\n! If a negative literal is passed, the corresponding atom is released.\n!\n! After this call, an external atom is no longer external and subject to\n! program simplifications. If the atom does not exist or is not external,\n! this is a noop.\n!\n! @param[in] control the target\n! @param[in] literal literal to release\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_release_external(
        control: *mut clingo_control_t,
        literal: clingo_literal_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Remove minimize constraints from the program.\n!\n! After this call, the program no longer contains any minimize constraints.\n!\n! @param[in] control the target\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_remove_minimize(control: *mut clingo_control_t) -> bool;
}
unsafe extern "C" {
    #[doc = "! Add to or replace the set of projection variables.\n!\n! If `append` is true, the function adds the given atoms to the set of projection variables. Otherwise, it discards\n! any previously added projection variables and sets the given atoms as the new set of projection variables.\n!\n! @param[in] control the target\n! @param[in] atoms the projection atoms to add/set\n! @param[in] size the number of atoms\n! @param[in] append whether to append to (true) or replace (false) any previously added projection variables\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_update_project(
        control: *mut clingo_control_t,
        atoms: *const clingo_atom_t,
        size: usize,
        append: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Register a custom propagator with the control object.\n!\n! If the sequential flag is set to true, the propagator is called\n! sequentially when solving with multiple threads.\n!\n! See the @ref Propagator module for more information.\n!\n! @param[in] control the target\n! @param[in] propagator the propagator\n! @param[in] data user data passed to the propagator functions\n! @param[in] sequential whether the propagator should be called sequentially\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_register_propagator(
        control: *mut clingo_control_t,
        propagator: *const clingo_propagator_t,
        data: *mut ::std::os::raw::c_void,
        sequential: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Check if the solver has determined that the internal program representation is conflicting.\n!\n! If this function returns true, solve calls will return immediately with an unsatisfiable solve result.\n! Note that conflicts first have to be detected, e.g. -\n! initial unit propagation results in an empty clause,\n! or later if an empty clause is resolved during solving.\n! Hence, the function might return false even if the problem is unsatisfiable.\n!\n! @param[in] control the target\n! @return whether the program representation is conflicting"]
    pub fn clingo_control_is_conflicting(control: *const clingo_control_t) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get a statistics object to inspect solver statistics.\n!\n! Statistics are updated after a solve call.\n!\n! See the @ref Statistics module for more information.\n!\n! @attention\n! The level of detail of the statistics depends on the stats option\n! (which can be set using @ref Configuration module or passed as an option when @link clingo_control_new creating the\n! control object@endlink). The default level zero only provides basic statistics, level one provides extended and\n! accumulated statistics, and level two provides per-thread statistics. Furthermore, the statistics object is best\n! accessed right after solving. Otherwise, not all of its entries have valid values.\n!\n! @param[in] control the target\n! @param[out] statistics the statistics object\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_statistics(
        control: *const clingo_control_t,
        statistics: *mut *const clingo_statistics_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Interrupt the active solve call (or the following solve call right at the beginning).\n!\n! @param[in] control the target"]
    pub fn clingo_control_interrupt(control: *mut clingo_control_t);
}
unsafe extern "C" {
    #[doc = "! Get low-level access to clasp.\n!\n! @attention\n! This function is intended for experimental use only and not part of the stable API.\n!\n! This function may return a <code>nullptr</code>.\n! Otherwise, the returned pointer can be cast to a ClaspFacade pointer.\n!\n! @param[in] control the target\n! @param[out] clasp pointer to the ClaspFacade object (may be <code>nullptr</code>)\n! @return whether the call was successful"]
    pub fn clingo_control_clasp_facade(
        control: *mut clingo_control_t,
        clasp: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get a configuration object to change the solver configuration.\n!\n! See the @ref Configuration module for more information.\n!\n! @param[in] control the target\n! @param[out] configuration the configuration object\n! @return whether the call was successful"]
    pub fn clingo_control_configuration(
        control: *mut clingo_control_t,
        configuration: *mut *mut clingo_configuration_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Configure how learnt constraints are handled during enumeration.\n!\n! If the enumeration assumption is enabled, then all information learnt from\n! the solver's various enumeration modes is removed after a solve call. This\n! includes enumeration of cautious or brave consequences, enumeration of\n! answer sets with or without projection, or finding optimal models, as well\n! as clauses added with clingo_solve_control_add_clause().\n!\n! @attention For practical purposes, this option is only interesting for single-shot solving\n! or before the last solve call to squeeze out a tiny bit of performance.\n! Initially, the enumeration assumption is enabled.\n!\n! @param[in] control the target\n! @param[in] enable whether to enable the assumption\n! @return whether the call was successful"]
    pub fn clingo_control_set_enable_enumeration_assumption(
        control: *mut clingo_control_t,
        enable: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Check whether the enumeration assumption is enabled.\n!\n! See ::clingo_control_set_enable_enumeration_assumption().\n! @param[in] control the target\n! @return whether using the enumeration assumption is enabled"]
    pub fn clingo_control_get_enable_enumeration_assumption(control: *mut clingo_control_t)
    -> bool;
}
unsafe extern "C" {
    #[doc = "! Enable automatic cleanup after solving.\n!\n! @note Cleanup is enabled by default.\n!\n! @param[in] control the target\n! @param[in] enable whether to enable cleanups\n! @return whether the call was successful\n!\n! @see clingo_control_cleanup()\n! @see clingo_control_get_enable_cleanup()"]
    pub fn clingo_control_set_enable_cleanup(control: *mut clingo_control_t, enable: bool) -> bool;
}
unsafe extern "C" {
    #[doc = "! Check whether automatic cleanup is enabled.\n!\n! See ::clingo_control_set_enable_cleanup().\n!\n! @param[in] control the target\n!\n! @see clingo_control_cleanup()\n! @see clingo_control_set_enable_cleanup()"]
    pub fn clingo_control_get_enable_cleanup(control: *mut clingo_control_t) -> bool;
}
unsafe extern "C" {
    #[doc = "! Return the symbol for a constant definition of form: <tt>\\#const name = symbol</tt>.\n!\n! @param[in] control the target\n! @param[in] name the name of the constant\n! @param[out] symbol the resulting symbol\n! @return whether the call was successful"]
    pub fn clingo_control_get_const(
        control: *const clingo_control_t,
        name: *const ::std::os::raw::c_char,
        symbol: *mut clingo_symbol_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Check if there is a constant definition for the given constant.\n!\n! @param[in] control the target\n! @param[in] name the name of the constant\n! @param[out] exists whether a matching constant definition exists\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_runtime if constant definition does not exist\n!\n! @see clingo_control_get_const()"]
    pub fn clingo_control_has_const(
        control: *const clingo_control_t,
        name: *const ::std::os::raw::c_char,
        exists: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get an object to inspect symbolic atoms (the relevant Herbrand base) used\n! for grounding.\n!\n! See the @ref SymbolicAtoms module for more information.\n!\n! @param[in] control the target\n! @param[out] atoms the symbolic atoms object\n! @return whether the call was successful"]
    pub fn clingo_control_symbolic_atoms(
        control: *const clingo_control_t,
        atoms: *mut *const clingo_symbolic_atoms_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get an object to inspect theory atoms that occur in the grounding.\n!\n! See the @ref TheoryAtoms module for more information.\n!\n! @param[in] control the target\n! @param[out] atoms the theory atoms object\n! @return whether the call was successful"]
    pub fn clingo_control_theory_atoms(
        control: *const clingo_control_t,
        atoms: *mut *const clingo_theory_atoms_t,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Register a program observer with the control object.\n!\n! @param[in] control the target\n! @param[in] observer the observer to register\n! @param[in] replace just pass the grounding to the observer but not the solver\n! @param[in] data user data passed to the observer functions\n! @return whether the call was successful"]
    pub fn clingo_control_register_observer(
        control: *mut clingo_control_t,
        observer: *const clingo_ground_program_observer_t,
        replace: bool,
        data: *mut ::std::os::raw::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Register a backend with the control object.\n!\n! This function is similar to clingo_control_register_observer except that\n! clingo's internal backends can be selected.\n!\n! @param[in] control the target\n! @param[in] type the kind of backend to register\n! @param[in] file the file to write the result to\n! @param[in] replace just pass the grounding to the backend but not the solver\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc\n! - ::clingo_error_runtime (for example if the file could not be opened)"]
    pub fn clingo_control_register_backend(
        control: *mut clingo_control_t,
        type_: clingo_backend_type_t,
        file: *const ::std::os::raw::c_char,
        replace: bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = "! Get an object to add ground directives to the program.\n!\n! See the @ref ProgramBuilder module for more information.\n!\n! @param[in] control the target\n! @param[out] backend the backend object\n! @return whether the call was successful; might set one of the following error codes:\n! - ::clingo_error_bad_alloc"]
    pub fn clingo_control_backend(
        control: *mut clingo_control_t,
        backend: *mut *mut clingo_backend_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug)]
pub struct clingo_options {
    _unused: [u8; 0],
}
#[doc = "! Object to add command-line options."]
pub type clingo_options_t = clingo_options;
#[doc = "! Callback to print a model in default format.\n!\n! @param[in] data user data for the callback\n!\n! @return whether the call was successful"]
pub type clingo_default_model_printer_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> bool>;
#[doc = "! Callback to customize model printing.\n!\n! @param[in] model the model\n! @param[in] printer the default model printer\n! @param[in] printer_data user data for the printer\n! @param[in] data user data for the callback\n!\n! @return whether the call was successful"]
pub type clingo_model_printer_t = ::std::option::Option<
    unsafe extern "C" fn(
        model: *const clingo_model_t,
        printer: clingo_default_model_printer_t,
        printer_data: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
